<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Property-Based Tests - Real-Time Linguistic Bridge</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .test-pass {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-fail {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .test-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        .counter-example {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <h1>Property-Based Tests</h1>
    <p><em>Testing universal properties of the Real-Time Linguistic Bridge system</em></p>
    
    <div class="test-container">
        <h2>Test Controls</h2>
        <button onclick="runAllTests()">Run All Property Tests</button>
        <button onclick="clearResults()">Clear Results</button>
        <div id="test-summary"></div>
    </div>

    <div class="test-container">
        <h2>Test Results</h2>
        <div id="test-results"></div>
    </div>

    <!-- Load fast-check from CDN -->
    <script src="https://unpkg.com/fast-check@3.15.0/lib/bundle.js"></script>
    
    <!-- Load application components -->
    <script src="../tests/test-setup.js"></script>
    <script src="../frontend/script.js"></script>
    
    <script>
        // Property-based testing setup
        const fc = window.fastCheck;
        let testResults = [];

        function addResult(testName, passed, details, counterExample = null) {
            const result = {
                name: testName,
                passed,
                details,
                counterExample,
                timestamp: new Date().toISOString()
            };
            testResults.push(result);
            displayResult(result);
        }

        function displayResult(result) {
            const resultsDiv = document.getElementById('test-results');
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
            
            let html = `
                <h3>${result.passed ? '‚úÖ' : '‚ùå'} ${result.name}</h3>
                <p>${result.details}</p>
            `;
            
            if (result.counterExample) {
                html += `<div class="counter-example">Counter-example: ${JSON.stringify(result.counterExample, null, 2)}</div>`;
            }
            
            resultDiv.innerHTML = html;
            resultsDiv.appendChild(resultDiv);
        }

        function clearResults() {
            testResults = [];
            document.getElementById('test-results').innerHTML = '';
            document.getElementById('test-summary').innerHTML = '';
        }

        function updateSummary() {
            const passed = testResults.filter(r => r.passed).length;
            const total = testResults.length;
            const summaryDiv = document.getElementById('test-summary');
            
            summaryDiv.innerHTML = `
                <div class="test-result ${passed === total ? 'test-pass' : 'test-fail'}">
                    Tests: ${passed}/${total} passed
                </div>
            `;
        }

        // Property Test 1: Voice-to-Intent Processing Pipeline
        function testVoiceToIntentPipeline() {
            console.log('Running Property 1: Voice-to-Intent Processing Pipeline');
            
            try {
                const intentClassifier = new IntentClassifier();
                
                // Property: All valid text inputs should produce a valid intent object
                const textArbitrary = fc.string({ minLength: 1, maxLength: 100 });
                const languageArbitrary = fc.constantFrom('english', 'hindi', 'kannada');
                
                const property = fc.property(textArbitrary, languageArbitrary, async (text, language) => {
                    const intent = await intentClassifier.classifyIntent(text, language);
                    
                    // Intent must have required properties
                    return (
                        typeof intent === 'object' &&
                        typeof intent.type === 'string' &&
                        typeof intent.confidence === 'number' &&
                        intent.confidence >= 0 && intent.confidence <= 1 &&
                        ['bargaining', 'bulk_purchase', 'casual_inquiry'].includes(intent.type)
                    );
                });
                
                fc.assert(property, { numRuns: 50 });
                addResult('Property 1: Voice-to-Intent Processing Pipeline', true, 'All text inputs produce valid intent objects with proper structure and confidence scores');
                
            } catch (error) {
                addResult('Property 1: Voice-to-Intent Processing Pipeline', false, `Failed: ${error.message}`, error.counterexample);
            }
        }

        // Property Test 2: Intent Classification Accuracy
        function testIntentClassificationAccuracy() {
            console.log('Running Property 2: Intent Classification Accuracy');
            
            try {
                const intentClassifier = new IntentClassifier();
                
                // Property: Known keywords should consistently classify to expected intents
                const knownCases = [
                    { text: 'price kitna hai', language: 'hindi', expectedType: 'casual_inquiry' },
                    { text: 'discount dedo', language: 'hindi', expectedType: 'bargaining' },
                    { text: 'bulk order', language: 'english', expectedType: 'bulk_purchase' },
                    { text: 'what is the price', language: 'english', expectedType: 'casual_inquiry' }
                ];
                
                let allPassed = true;
                let failedCase = null;
                
                for (const testCase of knownCases) {
                    const intent = intentClassifier.classifyIntent(testCase.text, testCase.language);
                    if (intent.type !== testCase.expectedType) {
                        allPassed = false;
                        failedCase = testCase;
                        break;
                    }
                }
                
                addResult('Property 2: Intent Classification Accuracy', allPassed, 
                    allPassed ? 'Known keywords consistently classify to expected intent types' : 'Some known keywords failed to classify correctly',
                    failedCase);
                
            } catch (error) {
                addResult('Property 2: Intent Classification Accuracy', false, `Failed: ${error.message}`, error);
            }
        }

        // Property Test 3: Single-Turn Consistency
        function testSingleTurnConsistency() {
            console.log('Running Property 3: Single-Turn Consistency');
            
            try {
                const intentClassifier = new IntentClassifier();
                
                // Property: Same input should produce same output (deterministic)
                const testInputs = [
                    { text: 'price kya hai', language: 'hindi' },
                    { text: 'what is the cost', language: 'english' },
                    { text: 'bulk discount', language: 'english' }
                ];
                
                let allConsistent = true;
                let inconsistentCase = null;
                
                for (const input of testInputs) {
                    const result1 = intentClassifier.classifyIntent(input.text, input.language);
                    const result2 = intentClassifier.classifyIntent(input.text, input.language);
                    
                    if (result1.type !== result2.type || Math.abs(result1.confidence - result2.confidence) > 0.001) {
                        allConsistent = false;
                        inconsistentCase = { input, result1, result2 };
                        break;
                    }
                }
                
                addResult('Property 3: Single-Turn Consistency', allConsistent,
                    allConsistent ? 'Same inputs produce consistent outputs across multiple calls' : 'Inconsistent results detected',
                    inconsistentCase);
                
            } catch (error) {
                addResult('Property 3: Single-Turn Consistency', false, `Failed: ${error.message}`, error);
            }
        }

        // Property Test 5: Price Discovery Completeness
        function testPriceDiscoveryCompleteness() {
            console.log('Running Property 5: Price Discovery Completeness');
            
            try {
                const priceEngine = new PriceDiscoveryEngine();
                
                // Property: All price queries should return complete price information
                const productArbitrary = fc.constantFrom('rice', 'wheat', 'onion', 'tomato', 'potato');
                
                const property = fc.property(productArbitrary, async (product) => {
                    const priceData = await priceEngine.getMarketPrice(product);
                    
                    return (
                        typeof priceData === 'object' &&
                        typeof priceData.minPrice === 'number' &&
                        typeof priceData.avgPrice === 'number' &&
                        typeof priceData.maxPrice === 'number' &&
                        priceData.minPrice <= priceData.avgPrice &&
                        priceData.avgPrice <= priceData.maxPrice &&
                        priceData.minPrice > 0
                    );
                });
                
                fc.assert(property, { numRuns: 30 });
                addResult('Property 5: Price Discovery Completeness', true, 'All price queries return complete and valid price ranges');
                
            } catch (error) {
                addResult('Property 5: Price Discovery Completeness', false, `Failed: ${error.message}`, error.counterexample);
            }
        }

        // Property Test 6: Negotiation Assistance Comprehensiveness
        function testNegotiationAssistanceComprehensiveness() {
            console.log('Running Property 6: Negotiation Assistance Comprehensiveness');
            
            try {
                const negotiationAssistant = new NegotiationAssistant();
                
                // Property: All negotiation requests should provide actionable guidance
                const mockIntent = { type: 'bargaining', product: 'rice', confidence: 0.8 };
                const mockPriceData = { minPrice: 50, avgPrice: 60, maxPrice: 70, product: 'rice' };
                
                const guidance = negotiationAssistant.generateGuidance(mockIntent, mockPriceData, 'price too high');
                
                const isValid = (
                    typeof guidance === 'object' &&
                    typeof guidance.suggestion === 'string' &&
                    typeof guidance.reasoning === 'string' &&
                    guidance.suggestion.length > 0 &&
                    guidance.reasoning.length > 0
                );
                
                addResult('Property 6: Negotiation Assistance Comprehensiveness', isValid,
                    isValid ? 'Negotiation guidance provides complete suggestions and reasoning' : 'Incomplete negotiation guidance');
                
            } catch (error) {
                addResult('Property 6: Negotiation Assistance Comprehensiveness', false, `Failed: ${error.message}`, error);
            }
        }

        // Property Test 7: Response Language Consistency
        function testResponseLanguageConsistency() {
            console.log('Running Property 7: Response Language Consistency');
            
            try {
                const responseGenerator = new ResponseGenerator();
                
                // Property: Responses should match requested language
                const languages = ['english', 'hindi', 'kannada'];
                const mockData = {
                    intent: { type: 'casual_inquiry', product: 'rice' },
                    priceData: { minPrice: 50, avgPrice: 60, maxPrice: 70 },
                    negotiationGuidance: { suggestion: 'Fair price', reasoning: 'Market rate' }
                };
                
                let allConsistent = true;
                let failedLanguage = null;
                
                for (const language of languages) {
                    const response = responseGenerator.formatResponse(mockData, language);
                    
                    // Check if response contains language-appropriate content
                    const hasContent = response && typeof response.text === 'string' && response.text.length > 0;
                    
                    if (!hasContent) {
                        allConsistent = false;
                        failedLanguage = language;
                        break;
                    }
                }
                
                addResult('Property 7: Response Language Consistency', allConsistent,
                    allConsistent ? 'Responses generated successfully for all supported languages' : `Failed for language: ${failedLanguage}`,
                    failedLanguage ? { language: failedLanguage } : null);
                
            } catch (error) {
                addResult('Property 7: Response Language Consistency', false, `Failed: ${error.message}`, error);
            }
        }

        // Property Test 9: Privacy Protection
        function testPrivacyProtection() {
            console.log('Running Property 9: Privacy Protection');
            
            try {
                const privacyManager = new PrivacyManager();
                
                // Property: No sensitive data should persist after clearing
                const testData = {
                    audioData: new ArrayBuffer(1024),
                    transcription: 'sensitive voice data',
                    userInput: 'personal information'
                };
                
                // Simulate data storage and clearing
                privacyManager.clearAudioData();
                privacyManager.clearSensitiveData();
                
                // Check localStorage and sessionStorage are clean
                const hasLocalStorage = localStorage.length > 0;
                const hasSessionStorage = sessionStorage.length > 0;
                
                const isPrivacySafe = !hasLocalStorage && !hasSessionStorage;
                
                addResult('Property 9: Privacy Protection', isPrivacySafe,
                    isPrivacySafe ? 'No sensitive data persists in browser storage' : 'Privacy violation: data found in browser storage');
                
            } catch (error) {
                addResult('Property 9: Privacy Protection', false, `Failed: ${error.message}`, error);
            }
        }

        // Property Test 10: Error Handling Robustness
        function testErrorHandlingRobustness() {
            console.log('Running Property 10: Error Handling Robustness');
            
            try {
                const intentClassifier = new IntentClassifier();
                
                // Property: System should handle invalid inputs gracefully
                const invalidInputs = [
                    '', // empty string
                    null,
                    undefined,
                    '   ', // whitespace only
                    'a'.repeat(1000), // very long string
                ];
                
                let allHandled = true;
                let failedInput = null;
                
                for (const input of invalidInputs) {
                    try {
                        const result = intentClassifier.classifyIntent(input, 'english');
                        // Should return a valid fallback intent
                        if (!result || typeof result.type !== 'string') {
                            allHandled = false;
                            failedInput = input;
                            break;
                        }
                    } catch (error) {
                        // Should not throw errors, should handle gracefully
                        allHandled = false;
                        failedInput = input;
                        break;
                    }
                }
                
                addResult('Property 10: Error Handling Robustness', allHandled,
                    allHandled ? 'All invalid inputs handled gracefully with fallback responses' : 'Some invalid inputs caused errors',
                    failedInput !== null ? { input: failedInput } : null);
                
            } catch (error) {
                addResult('Property 10: Error Handling Robustness', false, `Failed: ${error.message}`, error);
            }
        }

        // Run all property tests
        async function runAllTests() {
            clearResults();
            
            console.log('üöÄ Starting Property-Based Test Suite...');
            
            // Run tests sequentially to avoid conflicts
            testVoiceToIntentPipeline();
            await new Promise(resolve => setTimeout(resolve, 100));
            
            testIntentClassificationAccuracy();
            await new Promise(resolve => setTimeout(resolve, 100));
            
            testSingleTurnConsistency();
            await new Promise(resolve => setTimeout(resolve, 100));
            
            testPriceDiscoveryCompleteness();
            await new Promise(resolve => setTimeout(resolve, 100));
            
            testNegotiationAssistanceComprehensiveness();
            await new Promise(resolve => setTimeout(resolve, 100));
            
            testResponseLanguageConsistency();
            await new Promise(resolve => setTimeout(resolve, 100));
            
            testPrivacyProtection();
            await new Promise(resolve => setTimeout(resolve, 100));
            
            testErrorHandlingRobustness();
            
            // Update summary
            setTimeout(updateSummary, 200);
            
            console.log('‚úÖ Property-Based Test Suite completed');
        }

        // Auto-run tests when page loads
        window.addEventListener('load', () => {
            console.log('Property-based testing framework loaded with fast-check');
            console.log('Ready to run tests with minimum 100 iterations per property');
        });
    </script>
</body>
</html>